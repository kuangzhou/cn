---
title: "R编程的那些事"
description: ''
layout: post
output: html_document
tags:
- R
- Programming
category: R
---
## 写在前面

人，最困难的莫过于认识自己。如果能对自己的人清楚的定位，那么就能有价值地活在世上。同样，作为一门工具，我们如果能对其利弊都了如指掌，将会更好地发挥工具自己的优势。本文将简要分析一下，在用R编程过程推荐和不推荐的操作，使编写的R程序更加高效。

## 关于内存管理
1. 在循环中尽量少用cbind, rbind。R当中处理矩阵的时候没有维数的限制，这给我们带来了很大的方便。但是，如果我们对矩阵进行扩充，如用$\text{x=cbind(x,temp)}$时，系统会开辟新的连续空间给最新的x。这样会造成内存的浪费。因此，如果能事先给定最终所得扩充后矩阵$X$的维数，那么系统只需要开辟一个连续的空间。

用cbind合并的例子：
```{r}
rm(list=ls())
gc()
a = memory.size(F)
N=1000
x=c()
for(i in 1:1000){
  x=cbind(matrix(runif(N),N,1),x);
}
dim(x)
b= memory.size(F)
# 内存增加了:
b-a
```
在事先指定X维数的例子
```{r}
rm(list = ls())
gc()
a = memory.size(F)
N = 1000
x = matrix(0,N,1000);
for(i in 1:1000){
  x[,i] = matrix(runif(N),N,1);
}
dim(x)
b = memory.size(F)
# 使用内存增加了:
b-a
```
有时，确实不能指定需要得到的扩充后矩阵的维数，比如在迭代运算当中。这时，我们可以通过在运算中清除变量和清除内存垃圾的办法。
```{r}
rm(list = ls())
gc()
a = memory.size(F)
N = 1000
x = c()
for(i in 1:1000){
  x1 = cbind(matrix(runif(N),N,1),x);
  rm(x)
  gc()
  x = x1
  rm(x1)
  gc()
}
dim(x)
b = memory.size(F)
# 使用内存增加了:
b-a
```

Remark: $\text{gc()}$函数通常是不需要的，因为在R的运行当中，当内存不够时系统会自动清理垃圾。这里只是为了对比实验结果所用。

## 关于矩阵化运算
2. R和matlab一样，可以进行矩阵运算。如果在编程中有矩阵的思想，将会避免显式循环，大大节省程序的执行时间。下面以计算一个样本的欧氏距离矩阵为例，进行对比。

一般的显式循环方法
```{r}
data(iris)
x = as.matrix(iris[,1:4]);
dis = matrix(0, nrow(x), nrow(x));
ptm <- proc.time();
for (i in 1:nrow(x))
  for (j in 1:nrow(x)){
    dis[i,j] = sqrt(sum((x[i,]-x[j,])^2));
}
proc.time()-ptm
```
用矩阵化的思想：
```{r}
data(iris)
x = as.matrix(iris[,1:4]);
dis1 = matrix(0, nrow(x), nrow(x));
ptm <- proc.time();
for (i in 1:nrow(x)){
  mat1 = t(matrix(x[i,],ncol(x),nrow(x)));
  dis1[i,] = sqrt(rowSums((x - mat1)^2));
}
proc.time()-ptm
```

两者的计算是等价的
```{r}
sum(dis1!=dis)
```
## 参考资料

[R的内存管理和垃圾清理](http://jliblog.com/archives/276)

## 未完
持续更新中...




